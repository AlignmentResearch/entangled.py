"""
Module `entangled.loom.task` presents us with a `Task`s that have
targets and a set of dependencies. A `Task` will have an abstract
method `run`. Then the purpose is to run those tasks in correct
order and possibly in parallel.
"""

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Generic, Optional, TypeVar, Union
import asyncio


T = TypeVar("T")
R = TypeVar("R")


@dataclass
class Failure(Generic[T]):
    task: T

    def __bool__(self):
        return False


@dataclass
class TaskFailure(Failure[T], Exception):
    message: str

    def __post_init__(self):
        Exception.__init__(self, self.message)


@dataclass
class DependencyFailure(Failure[T], Generic[T]):
    dependent: Failure[T]


@dataclass
class Ok(Generic[T, R]):
    task: Task[T, R]
    value: R

    def __bool__(self):
        return True


Result = Union[Failure, Ok[T, R]]


@dataclass
class Task(Generic[T, R]):
    """Base class for tasks that are tagged with type `T` (usually `str` or
    `Path`) and representing values of type `R`.

    To implement a specific task, you need to implement the asynchronous
    `run` method, which should return a value of `R` or throw `TaskFailure`.

    Attributes:
        targets: list of target identifiers, for instance paths that are
            generated by running a particular task.
        dependencies: list of dependency identifiers. All of these need to
            be realized before the task can run.
        result (property): value of the result, once the task was run. This
            throws an exception if accessed before the task is complete.
    """
    targets: list[T]
    dependencies: list[T]
    _lock: asyncio.Lock = field(default_factory=asyncio.Lock, init=False)
    _result: Optional[Result[T, R]] = field(default=None, init=False)

    def __bool__(self):
        return self._result is not None and bool(self._result)

    @property
    def result(self) -> R:
        if self._result is None:
            raise ValueError("Task has not run yet.")
        if not self._result:
            raise ValueError("Task has failed.")
        print(self._result)
        assert isinstance(self._result, Ok)
        return self._result.value

    async def run(self) -> R:
        raise NotImplementedError()

    async def run_after_deps(self, recurse) -> Result[T, R]:
        for dep in self.dependencies:
            if not (dep_result := await recurse(dep)):
                return DependencyFailure(self, dep_result)
        try:
            result = await self.run()
            return Ok(self, result)
        except TaskFailure as f:
            return f

    async def run_cached(self, recurse) -> Result[T, R]:
        async with self._lock:
            if self._result is not None:
                return self._result
            self._result = await self.run_after_deps(recurse)
            return self._result


@dataclass
class TaskDB(Generic[T, R]):
    """Collect tasks and coordinate running a task from a task identifier."""
    tasks: list[Task[T, R]] = field(default_factory=list)
    index: dict[T, Task[T, R]] = field(default_factory=dict)

    async def run(self, t: T) -> Result[T, R]:
        return await self.index[t].run_cached(self.run)

    def add(self, task: Task[T, R]):
        """Add a task to the DB."""
        self.tasks.append(task)
        for target in task.targets:
            self.index[target] = task

    def clean(self):
        self.tasks = []
        self.index = {}

